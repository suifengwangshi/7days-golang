之前，我们使用哈希表map来存储路由表，存储键值对，索引非常高效，但是键值对的方式只能用来索引静态路由。
如果想要支持类似于/hello/:name这样的动态路由怎么办呢？所谓动态路由，即一条路由规则可以匹配某一类型而非某
一条固定的路由。例如/hello/:name可以匹配/hello/geektutu 和 hello/jack等。
动态路由有很多种实现方式，支持的规则、性能等有很大的差异。例如开源的路由实现gorouter支持在路由规则中嵌入
正则表达式；另一个开源实现httprouter就不支持正则表达式。

实现动态路由最常用的数据结构，被称为前缀树(Trie树)，每一个节点的所有子节点都拥有相同的前缀，适用于路由匹配。
例如：
/:lang/doc
/:lang/tutorial
/:lang/intro
/about
/p/blog
/p/related

HTTP请求的路径恰好是由 / 分隔的多段构成的，因此每一段可以作为前缀树的一个节点。我们通过树结构查询，如果中间
某一层的节点都不满足条件，那么就说明没有匹配到的路由，查询结束。

